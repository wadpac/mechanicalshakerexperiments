---
title: "Frequency domain analyses"
author: "Annelinde Lettink"
output: 
  html_notebook:
    toc: true
    toc_depth: 6  # upto four depths of headings (specified by #, ##, ###, ####, ##### and ######)
---

```{r Setup and load data, include=FALSE}
#install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(dev = 'pdf')

rm(list=ls())
graphics.off()

# Update to be your local directory, if all goes well this is the only line you will have to update
shaker_experiments_folder = "/Users/annelindelettink/Documents/Work MacBook Pro Annelinde/Mechanical Shaker Machine"
# shaker_experiments_folder = "~/data/VUMC/shaker_experiments"

#====================================================================================
# Specify file paths
datadir = paste0(shaker_experiments_folder, "/analyses/")
if (!dir.exists(datadir)) {
  stop(paste0("Directory does not exist: ", datadir))
}

# Load cleaned mechanical shaker machine data for both experiments
filename_high = paste0(datadir, "ms_flat_HA_cleaned_high.RData") 
filename_low = paste0(datadir, "ms_flat_HA_cleaned_low.RData") 
if (!file.exists(filename_high)) {
  stop(paste0("File does not exist: ", filename_high))
}
load(filename_high)
if (!file.exists(filename_low)) {
  stop(paste0("File does not exist: ", filename_low))
}
load(filename_low)
rm(filename_high, filename_low)
```

```{r Functions, include=FALSE}
#' deriveSpectrum
#'
#' @description 'deriveSpectrum' derives the frequency spectrum of a signal
#'
#' @param x Vector that contains the values of the signal (i.e., acceleration)
#' @param sampling_frequency Integer that indicates the sampling frequency of the signal (i.e., the average number of samples obtained in one second in Hz)
#' @param file_name String to indicate the name of the plot (i.e., "spectrum" result in the following name for plot 1 "spectrum_1.jpeg").
#' @param plot Boolean, default is TRUE the derived spectrum will be plotted
#' @param XLIM Vector that limits the frequency content of the plot, default is c(0, 5) to limit the frequency content to 5 Hz (as 250 rpm / 60 = 4.1667 Hz is the expected max)
#' @return An object of class "spec", which is a list containing at least the following components: 
#' \item{freq}{Vector of frequencies at which the spectral density is estimated.} 
#' \item{spec}{Vector (for univariate series) or matrix (for multivariate series) of estimates of the spectral density at frequencies corresponding to freq.}
#' \item{coh}{NULL for univariate series. For multivariate time series, a matrix containing the squared coherency between different series.}  
#' \item{phase}{NULL for univariate series. For multivariate time series a matrix containing the cross-spectrum phase between different series.} 
#' \item{series}{The name of the time series.}
#' \item{snames}{For multivariate input, the names of the component series.}
#' \item{method}{The method used to calculate the spectrum.} 
#' @export
deriveSpectrum <- function(x, sampling_frequency, file_name, plot = TRUE, XLIM = c(0, 5)) {
  specd <- spectrum(x, log = "no", plot = FALSE) # Default calculate spectrum on log-scale, but we use raw data
  
  # Frequency axis of the spectrum, specd, is calculated in terms of cycles per sampling interval
  delta <- 1/sampling_frequency
  specd$specx <- specd$freq/delta # Converts to cycles per unit time (divide by sampling interval)
  specd$specy <- 2*specd$spec # Multiply the spectrum by 2 to make it actually equal to variance
  
  #Save the frequency spectrum plot and zoom in on low-frequencies (at most 5 based on max rpm)
  if (plot == TRUE){
    jpeg(paste(datadir, paste0(paste(file_name, file, sep = "_"), ".jpeg"), sep = "/plots/"),
         width=600, height=500, res=120) # start export
    plot(specd$specx, specd$specy,
         main = "HA", xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l") 
    dev.off()
  }
  return(specd)
}

#' deriveMeanSpectrum
#'
#' @description 'deriveMeanSpectrum' derives the mean frequency spectrum from the derived spectra
#'
#' @param spectra A list containing the raw spectra over which the mean will be derived
#' @return A list containing two following elements: 
#' \item{x}{Vector of frequencies at which the spectral density (y) is estimated} 
#' \item{y}{Vector of estimates of the spectral density at frequencies corresponding to frequencies (x)}
#' @export
deriveMeanSpectrum <- function(spectra) {
  df_specx <- data.frame()
  df_specy <- data.frame()
  for(spectrum in 1:length(spectra)){
    df_specx <- rbind(df_specx, spectra[[spectrum]]$specx)
    df_specy <- rbind(df_specy, spectra[[spectrum]]$specy)
  }
  x <- colMeans(df_specx)
  y <- colMeans(df_specy)
  spec <- list(x = x, y = y)
  return(spec)
}

#' derivePeaks
#'
#' @description 'derivePeaks' derives peaks from the mean frequency spectrum
#'
#' @param mean.spec A list containing estimates of the spectral density (y) at corresponding frequencies (x)
#' @param sampling_frequency An integer indicating whether peaks are derived for the low or high sampling frequency experiment, one of c(25, 100) 
#' @param XLIM Vector that limits the frequency content, default is c(0, 5) to limit the frequency content to 5 Hz (as 250 rpm / 60 = 4.1667 Hz is the expected max)
#' @param plot Boolean, default is TRUE the derived peaks will be plotted over the mean frequency spectrum
#' @return A vector indicating the frequencies at which the peaks occur 
#' @export
derivePeaks <- function(mean.spec, sampling_frequency, XLIM = c(0, 5), plot = TRUE) {
  peaks <- pracma::findpeaks(mean.spec$y[mean.spec$x <= XLIM[2]], 
                             minpeakheight = mean(mean.spec$y) + sd(mean.spec$y) , 
                             minpeakdistance = 4*sampling_frequency)
  local.max <- mean.spec$x[sort(peaks[,2])]
  local.max <- local.max[local.max <= XLIM[2]]
  
  if (plot == TRUE){
    plot <- plot(mean.spec$x, mean.spec$y,  xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l", main = "Detected peaks")
    for(max in 1:length(local.max)){
      p <- plot + abline(v=local.max[max], col = "red")
    }
  }
  return(local.max)
}

#' deriveBins
#'
#' @description 'deriveBins' derives frequency bins from the peaks detected in the mean frequency spectrum
#'
#' @param peaks A vector containing the corresponding frequencies of where the peaks (local maxima) are located
#' @param mean.spec A list containing estimates of the spectral density (y) at corresponding frequencies (x)
#' @param XLIM Vector that limits the frequency content, default is c(0, 5) to limit the frequency content to 5 Hz (as 250 rpm / 60 = 4.1667 Hz is the expected max)
#' @param plot Boolean, default is TRUE the derived bins will be plotted over the mean frequency spectrum
#' @return A vector indicating the frequencies at which the peaks occur 
#' @export
deriveBins <- function(peaks, mean.spec, XLIM = c(0, 5), plot = TRUE) {
  peaks <- c(XLIM[1], peaks)
  
  freq.bin <- c()
  for(bin in 2:length(peaks)){
    freq.bin <- c(freq.bin, (peaks[bin-1] + peaks[bin])/2)
  }
  if(plot == TRUE){
    plot <- plot(mean.spec$x, mean.spec$y,  xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l", main = "Derived frequency cut-offs")
    for(bin in 1:length(freq.bin)){
      p <- plot + abline(v=freq.bin[bin], col = "red")
    }  
  }
  freq.bin <- c(XLIM[1], freq.bin, XLIM[2])
  return(freq.bin)
}

#' deriveComparisonValues
#'
#' @description 'deriveComparisonValues' derives the dominant frequency and the mean power spectral density from a frequency spectrum
#'
#' @param spectrum An object of class "spec"
#' @param freqBins Vector containing frequency values that define the frequency bins (can be derived using the function 'deriveBins') 
#' @return Data.frame consisting of two columns: \item{domFreq}{The dominant frequency of the signal in each frequency bin} \item{meanPSD}{The mean power spectral density of the signal in each frequency bin}
#' @export
deriveComparisonValues <- function(spectrum, freqBins){
  df <- data.frame()
  for(i in 1:(length(freqBins)-1)){
    lower <- freqBins[i]
    upper <- freqBins[i+1]
    index <- which(spectrum$specx >= lower & spectrum$specx <= upper)
    df[i, 1] <- spectrum$specx[index[which.max(spectrum$specy[index])]] # dominant frequency
    df[i, 2] <- mean(spectrum$specy[index]) # mean power spectral density
  }
  colnames(df) <- c("domFreq", "meanPSD")
  return(df)
}

#' createBoxplot
#'
#' @description 'createBoxplot' creates a boxplot between or within devices for the dominant frequency or the mean power spectral density per frequency bin
#'
#' @param data A data set containing the comparison values for the experiment
#' @param freqBins A vector that indicates the cut-offs for the freqency bins
#' @param outcome String containing the type of the comparison value. One of c("domFreq", "meanPSD") 
#' @param experiment String to indicate the experiment. One of c("low", "high") 
#' @param relative Boolean to indicate whether the values need to be plotted relatively to the frequency bin mean. One of c("TRUE", "FALSE") 
#' @return Boxplot between or within devices for the outcome (y-axis) per frequency bin (x-axis)
#' @export
createBoxplot <- function(data, freqBins, outcome = c("domFreq", "meanPSD"), experiment = c("low", "high"), relative = c(TRUE, FALSE)){
  if (outcome == "domFreq" & relative == FALSE){
    label = "Dominant frequency (Hertz)"
  } else if (outcome == "meanPSD" & relative == FALSE){
    label = "Mean power spectral density (g2/Hertz)"
  } else if (outcome == "domFreq" & relative == TRUE){
    label = "Deviation from mean bin dominant frequency (%)"
  } else {
    label = "Deviation from mean bin power spectral density (%)"
  }
  if (experiment == "low"){
    bins = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12")
      } else if (experiment == "high"){
    bins = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13")
    }
  bin.labels <- c()
  for (bin in 2:length(freqBins)){
    bin.labels <- c(bin.labels, paste(round(freqBins[bin-1], digits = 2), 
                                      round(freqBins[bin], digits = 2), sep = "-"))
  }
  if(relative == TRUE){
    bin.means <- aggregate(data[, c("domFreq", "meanPSD")], list(data$bin), mean)
    if(outcome == "domFreq"){
        data <- transform(data, domFreq.binmean = ave(domFreq, bin.labels, FUN = mean))
        data$rel <- (abs(data$domFreq - data$domFreq.binmean)/data$domFreq.binmean)*100
    } else{
        data <- transform(data, meanPSD.binmean = ave(meanPSD, bin.labels, FUN = mean))
        data$rel <- (abs(data$meanPSD - data$meanPSD.binmean)/data$meanPSD.binmean)*100
      #data <- transform(data, perc = ave(meanPSD, bin.labels, FUN = prop.table)*100)
    }
    outcome = "rel"
  }
  
  boxplot <- ggpubr::ggboxplot(data, x = "bin", y = outcome, color = "brand",
                               xlab = "Shaker frequency (Hertz)", ylab = label, 
                                order = bins,
                               font.label = list(size = 8, color = "black")) +
    ggpubr::font("xlab", size = 6, color = "black") +
    ggpubr::font("x.text", size = 6, color = "black") + 
    ggpubr::font("ylab", size = 6, color = "black") +
    ggpubr::font("y.text", size = 6, color = "black") + 
    ggpubr::font("legend.title", size = 8, color = "black") +
    ggpubr::font("legend.text", size = 8, color = "black") + 
    ggplot2::scale_x_discrete(breaks=bins,
                     labels= bin.labels)
  return(boxplot)
}

#' calculateContrasts
#'
#' @description 'calculateContrasts' function prints the contrasts for the differences between brands for each bin
#'
#' @param model Model object for which the output will be printed
#' @param data Data.frame object that includes the comparison values 
#' @return Prints pairwise comparisons
#' @export
calculateContrasts <- function(model, data){
  #Step 1: Compute estimated marginal means for the desired fixed effects
  emmRes <- emmeans::emmeans(model, comparison="pairwise", 
                                         specs= ~ bin*brand, adjust="sidak", data = data)
  #Step 2: Show pairwise contrasts for the fixed effects
  ct <- emmeans::contrast(emmRes, "pairwise")

  #Step 3: Focus on differences between brands in bins
  ct.df <- as.data.frame(ct)

  focusOfInterest <- c()
  check <- strsplit(ct.df$contrast, " ")
  for (row in 1:nrow(ct.df)) {
    focusOfInterest <- c(focusOfInterest, (check[[row]][1] == check[[row]][4] 
                                           & check[[row]][2] !=   check[[row]][5])) #focus on rows where bin is the same, but the brand differs.
  }
  return(print(ct.df[focusOfInterest,]))
}
```

# Frequency spectra

We derived frequency spectra separately for both experiments from raw acceleration signals using Fourier transformation. 
We then used the mean of the frequency spectra to the derive frequency bins, over which aggregated outcome values (i.e., dominant frequency and mean power spectral density) were calculated for statistical comparison between brands. This was done by detecting the frequency peaks in the mean frequency spectra, and deriving the frequencies in Hertz associated with these peaks. We divided these frequencies by two to derive the frequency cut-offs for the bins to ensure the peaks fell within these bins. Aggregated outcome values (i.e., dominant frequency and mean power spectral density) were calculated over the frequency bins for statistical comparison between brands.
To ensure the peaks of the frequency spectra fell within these frequency bins, we plotted all acceleration signals overlayed in one plot and separately for all signals, with red vertical lines indicating the boundaries of the derived bins.

```{r Settings for frequency spectra, include=FALSE}
# Plot parameters
plot = TRUE
xlabel = "Frequency (Hertz)"
ylabel = "Spectral Density (g2/Hertz)"
XLIM = c(0, 5) # Limit frequency content to 5 Hz (as 250 rpm / 60 = 4.1667 Hz is the expected max)
```

```{r Derive frequency spectra low sampling frequency experiment, echo=FALSE}
# DERIVE RAW FREQUENCY SPECTRA (for visual inspection and save data for further analysis)
raw.spectra_low <- list() 

for (file in 1:length(clean_data_low$frequencyDomain$data)) { # for all accelerometer files
  sampling_frequency <- as.numeric(clean_data_low$frequencyDomain$specifications$sampling_frequency[file])  
  HA <- clean_data_low$frequencyDomain$data[[file]]$HA #for horizontal axis
  rawSpectrum <- deriveSpectrum(HA, sampling_frequency, file_name = names(clean_data_low$frequencyDomain$data)[[file]])
  raw.spectra_low[[file]] <- rawSpectrum
}
rm(rawSpectrum, file)
names(raw.spectra_low) <- clean_data_low$frequencyDomain$specifications$label  

mean.freqspec_low <- deriveMeanSpectrum(raw.spectra_low)
```

```{r Derive frequency spectra high sampling frequency experiment, echo=FALSE}
# DERIVE RAW FREQUENCY SPECTRA (for visual inspection and save data for further analysis)
raw.spectra_high <- list() 

for (file in 1:length(clean_data_high$frequencyDomain$data)) { # for all accelerometer files
  sampling_frequency <- as.numeric(clean_data_high$frequencyDomain$specifications$sampling_frequency[file])  
  HA <- clean_data_high$frequencyDomain$data[[file]]$HA #for horizontal axis
  rawSpectrum <- deriveSpectrum(HA, sampling_frequency, file_name = names(clean_data_high$frequencyDomain$data)[[file]])
  raw.spectra_high[[file]] <- rawSpectrum
}
rm(rawSpectrum, file)
names(raw.spectra_high) <- clean_data_high$frequencyDomain$specifications$label

mean.freqspec_high <- deriveMeanSpectrum(raw.spectra_high)
```

```{r Save raw spectra, include=FALSE}
raw_spectra <- list(high = raw.spectra_high, high_mean = mean.freqspec_high, specifications_high = clean_data_high$frequencyDomain$specifications,
                    low = raw.spectra_low, low_mean = mean.freqspec_low, specifications_low = clean_data_low$frequencyDomain$specifications) # Save derived raw spectra for HA in one list
save(raw_spectra, file = paste0(datadir, "frequency_spectra.RData"))
rm(raw.spectra_high, raw.spectra_low, HA, sampling_frequency)

#load(paste0(datadir, "frequency_spectra.RData"))
```

## Low sampling frequency experiment

### Mean frequency spectra

```{r Plot mean frequency spectrum low sampling frequency, echo=FALSE}
plot(mean.freqspec_low$x, mean.freqspec_low$y, xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l", main = "Mean frequency spectrum low sampling frequency experiment")
rm(mean.freqspec_low)
```

### Derive frequency bins
```{r Derive frequency bins low sampling frequency, echo=FALSE}
peaks_low <- derivePeaks(raw_spectra$low_mean, 25, XLIM, plot = TRUE)
bins_low <- deriveBins(peaks_low, raw_spectra$low_mean, XLIM = c(0, 5), plot = TRUE) 
```

### Frequency spectrum plots

#### Overlay all frequency spectra

```{r Overlay all spectra low sampling frequency experiment, echo=FALSE}
plot <- plot(raw_spectra$low[[1]]$specx, raw_spectra$low[[1]]$specy, main = "Overlay all frequency spectra", 
       xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l")
for(i in 1:length(bins_low)){
    plot <- plot + abline(v=bins_low[i], col = "red")
  }  

for (spec in 2:length(raw_spectra$low)) {
  plot + lines(raw_spectra$low[[spec]]$specx, raw_spectra$low[[spec]]$specy, type = "l")
  
}
rm(spec, i)
```
#### Plot frequency spectra separately

```{r Plot spectra low sampling frequency experiment, echo=FALSE}
for (spec in 1:length(raw_spectra$low)) {
  spectrum <- raw_spectra$low[[spec]]
  title <- paste("Frequency spectrum plot: ", raw_spectra$specifications_low$label[[spec]])
  plot(spectrum$specx, spectrum$specy, main = title, 
       xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l")
  for(i in 1:length(bins_low)){
    abline(v=bins_low[i], col = "red")
  }  
}
rm(spec, title, spectrum, i)
```

## High sampling frequency experiment

### Mean frequency spectra

```{r Plot mean frequency spectrum high sampling frequency, echo=FALSE}
plot(mean.freqspec_high$x, mean.freqspec_high$y, xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l", main = "Mean frequency spectrum high sampling frequency experiment")
rm(mean.freqspec_high)
```

### Derive frequency bins

```{r Derive frequency bins high sampling frequency, echo=FALSE}
peaks_high <- derivePeaks(raw_spectra$high_mean, 100, XLIM, plot = TRUE)
bins_high <- deriveBins(peaks_high, raw_spectra$high_mean, XLIM = c(0, 5), plot = TRUE) 
```

### Frequency spectrum plots

#### Overlay all frequency spectra

```{r Overlay all spectra high sampling frequency experiment, echo=FALSE}
plot <- plot(raw_spectra$high[[1]]$specx, raw_spectra$high[[1]]$specy, main = "Overlay all frequency spectra", 
       xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l")
for(i in 1:length(bins_high)){
    plot <- plot + abline(v=bins_high[i], col = "red")
  }  

for (spec in 2:length(raw_spectra$high)) {
  plot + lines(raw_spectra$high[[spec]]$specx, raw_spectra$high[[spec]]$specy, type = "l")
  
}
rm(spec, i)
```

#### Plot frequency spectra separately

```{r Plot spectra high sampling frequency experiment, echo=FALSE}
#load(paste0(datadir, "frequency_spectra.RData"))

for (spec in 1:length(raw_spectra$high)) {
  title <- paste("Frequency spectrum plot: ", raw_spectra$specifications_high$label[[spec]])
  plot(raw_spectra$high[[spec]]$specx, raw_spectra$high[[spec]]$specy, main = title, 
       xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l") 
  for(i in 1:length(bins_high)){
    abline(v=bins_high[i], col = "red")
  }  
}
rm(spec, i)
```

```{r Compute dominant frequency (domFreq) and mean power spectral density (meanPSD) for HA, include = FALSE}
comparison_values_low <- list()
for(spectrum in 1:length(raw_spectra$low)){ 
  comparison_values_low[[spectrum]] <- deriveComparisonValues(raw_spectra$low[[spectrum]], bins_low)
}
names(comparison_values_low) <- names(raw_spectra$low)

comparison_values_high <- list()
for(spectrum in 1:length(raw_spectra$high)){ 
  comparison_values_high[[spectrum]] <- deriveComparisonValues(raw_spectra$high[[spectrum]], bins_high)
}
names(comparison_values_high) <- names(raw_spectra$high)
#cat("\nSaving data...")
comparison_values <- list(high = comparison_values_high, low = comparison_values_low)
save(comparison_values, file = paste0(datadir, "domFreq_meanPSD.RData")) 

rm(spectrum, comparison_values_high, comparison_values_low)
```

```{r WIDE FORMAT: Prepare data set for statistical analyses, include = FALSE}
# Wide format: for both experiments and outcomes domFreq and meanPSD

df_wide_low <- data.frame()
id <- names(comparison_values$low)
df_wide_low <- cbind(id, clean_data_low$frequencyDomain$specifications$brand, clean_data_low$frequencyDomain$specifications$sampling_frequency,
                 clean_data_low$frequencyDomain$specifications$dynamic_range)
domFreq_wide_low <- data.frame() 
meanPSD_wide_low <- data.frame()
for (accelerometer in 1:length(comparison_values$low)) {
  domFreq_wide_low <- rbind(domFreq_wide_low, comparison_values$low[[accelerometer]]$domFreq)
  meanPSD_wide_low <- rbind(meanPSD_wide_low, comparison_values$low[[accelerometer]]$meanPSD)
}
domFreq_ms_wide_low <- cbind(df_wide_low, domFreq_wide_low)
colnames(domFreq_ms_wide_low) <- c("serialnumber", "brand", "sampling_frequency", "dynamic_range", 
                               "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12")
meanPSD_ms_wide_low <- cbind(df_wide_low, meanPSD_wide_low)
colnames(meanPSD_ms_wide_low) <- c("serialnumber", "brand", "sampling_frequency", "dynamic_range", 
                               "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12")
rm(df_wide_low, id, domFreq_wide_low, meanPSD_wide_low, accelerometer)

df_wide_high <- data.frame()
id <- names(comparison_values$high)
df_wide_high <- cbind(id, clean_data_high$frequencyDomain$specifications$brand, clean_data_high$frequencyDomain$specifications$sampling_frequency,
                 clean_data_high$frequencyDomain$specifications$dynamic_range)
domFreq_wide_high <- data.frame() 
meanPSD_wide_high <- data.frame()
for (accelerometer in 1:length(comparison_values$high)) {
  domFreq_wide_high <- rbind(domFreq_wide_high, comparison_values$high[[accelerometer]]$domFreq)
  meanPSD_wide_high <- rbind(meanPSD_wide_high, comparison_values$high[[accelerometer]]$meanPSD)
}
domFreq_ms_wide_high <- cbind(df_wide_high, domFreq_wide_high)
colnames(domFreq_ms_wide_high) <- c("serialnumber", "brand", "sampling_frequency", "dynamic_range", 
                               "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13")
meanPSD_ms_wide_high <- cbind(df_wide_high, meanPSD_wide_high)
colnames(meanPSD_ms_wide_high) <- c("serialnumber", "brand", "sampling_frequency", "dynamic_range", 
                               "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13")
rm(df_wide_high, id, domFreq_wide_high, meanPSD_wide_high, accelerometer, comparison_values, clean_data_high, clean_data_low)
```

```{r LONG FORMAT: Prepare data set for statistical analyses, include = FALSE}
# Combining domFreq and meanPSD (gather columns for outcome variables)
library(tidyverse)

domFreq_long_low <- domFreq_ms_wide_low %>%
  gather(key = "bin", value = "domFreq", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12") %>%
  rstatix::convert_as_factor(serialnumber, bin, brand, sampling_frequency, dynamic_range)
meanPSD_long_low <- meanPSD_ms_wide_low %>%
  gather(key = "bin", value = "meanPSD", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12") %>%
  rstatix::convert_as_factor(serialnumber, bin, brand, sampling_frequency, dynamic_range)
df_low <- merge(domFreq_long_low, meanPSD_long_low) # Join both data.frame objects to derive a single dataset
rm(domFreq_long_low, domFreq_ms_wide_low, meanPSD_long_low, meanPSD_ms_wide_low)
df_low <- df_low[order(df_low$serialnumber),]

domFreq_long_high <- domFreq_ms_wide_high %>%
  gather(key = "bin", value = "domFreq", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13") %>%
  rstatix::convert_as_factor(serialnumber, bin, brand, sampling_frequency, dynamic_range)
meanPSD_long_high <- meanPSD_ms_wide_high %>%
  gather(key = "bin", value = "meanPSD", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13") %>%
  rstatix::convert_as_factor(serialnumber, bin, brand, sampling_frequency, dynamic_range)
df_high <- merge(domFreq_long_high, meanPSD_long_high) # Join both data.frame objects to derive a single dataset
rm(domFreq_long_high, domFreq_ms_wide_high, meanPSD_long_high, meanPSD_ms_wide_high)
df_high <- df_high[order(df_high$serialnumber),]

df_long <- list(low = df_low, high = df_high)
#cat("\nSaving data...")
save(df_long, file = paste0(datadir, "domfreq_meanPSD_long.RData"))
rm(df_high, df_low)

#load(datadir, "df_long.RData")
```

# Statistical comparison: Mixed model analyses

This section presents the statistical comparison of the frequency spectra in terms of the aggregated dominant frequency and mean power spectral density for each frequency bin per sampling frequency experiment. The mixed models for the two outcomes mean power spectral density and dominant frequency are presented separately.

## Mean power spectral density: meanPSD ~ brand + bin + brand*bin

### Low sampling frequency experiment
```{r Fit model meanPSD for low sampling frequency experiment, echo=FALSE}
meanPSD_interaction_id_low <- lme4::lmer(meanPSD ~ bin*brand + (1 | serialnumber), REML = TRUE, data = df_long$low)

# Evaluate if adding a random intercept for frequency bin is necessary
meanPSD_interaction_id_bin_low <- lme4::lmer(meanPSD ~ bin*brand + (1 | serialnumber) + (1 | bin), REML = TRUE, data = df_long$low) # No convergence, so use the simpler model
anova(meanPSD_interaction_id_low, meanPSD_interaction_id_bin_low, refit = FALSE) # This is not necessary, so use simplest model
rm(meanPSD_interaction_id_bin_low)
```

#### Model assumption: normal distribution of residuals
```{r Mean PSD Model assumptions low sampling frequency experiment, echo=FALSE}
ggpubr::ggqqplot(df_long$low, "meanPSD", facet.by = "bin", title = "QQ-plot mean power spectral density")
residuals_meanPSD <- resid(meanPSD_interaction_id_low)
#summary(residuals_meanPSD)
hist(residuals_meanPSD)
```
#### Model summary
```{r Model summary meanPSD low sampling frequency experiment, echo=FALSE}
car::Anova(meanPSD_interaction_id_low, type="II", test.statistic="F")
require(lmerTest)
test.meanPSD_low <- as(meanPSD_interaction_id_low, "merModLmerTest")
print(summary(test.meanPSD_low, ddf="Kenward-Roger"), correlation = FALSE)
#summary(meanPSD_interaction_id_low)
vcov(meanPSD_interaction_id_low, type = "random")

#drop1(meanPSD_interaction_id_low,scope=c("brand","bin","bin:brand"),test="Chisq")
```

#### Pairwise comparisons
##### Bin
```{r Calculate contrasts bin meanPSD for low sampling frequency experiment, echo=FALSE}
maineffect_bin <- emmeans::emmeans(meanPSD_interaction_id_low, comparison="pairwise", 
                                         specs= ~ bin, adjust="sidak", data = df_long$low)
maineffect_bin
emmeans::contrast(maineffect_bin, "pairwise")
```

##### Brand
```{r Calculate contrasts brand meanPSD for low sampling frequency experiment, echo=FALSE}
maineffect_brand <- emmeans::emmeans(meanPSD_interaction_id_low, comparison="pairwise", 
                                         specs= ~ brand, adjust="sidak", data = df_long$low)
maineffect_brand
emmeans::contrast(maineffect_brand, "pairwise")
```

##### Interaction effect
```{r Calculate contrasts model meanPSD for low sampling frequency experiment, echo=FALSE}
calculateContrasts(meanPSD_interaction_id_low, df_long$low)

emmeans::emmeans(meanPSD_interaction_id_low, specs = c("bin", "brand"))

```

#### Boxplot
This section presents a boxplot to illustrate differences in mean power spectral density between brands per bin for the low sampling frequency experiment.

```{r Create boxplot meanPSD low sampling frequency experiment, include=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_long.RData"))
bxp_psd_low <- createBoxplot(df_long$low, bins_low, outcome = "meanPSD", experiment = "low", relative = FALSE)
bxp_psd_low_perc <- createBoxplot(df_long$low, bins_low, outcome = "meanPSD", experiment = "low", relative = TRUE)

gridExtra::grid.arrange(bxp_psd_low, bxp_psd_low_perc, nrow=1) #arranges plots within grid
meanpsd_low <- gridExtra::arrangeGrob(bxp_psd_low + ggplot2::theme(legend.position="none"), 
                            bxp_psd_low_perc + ggplot2::theme(legend.position="bottom"), nrow=2) #generates meanpsd_low 
ggplot2::ggsave(file=paste0(datadir, "plots/boxplots_meanpsd_LOW.pdf"), meanpsd_low) #saves meanpsd_low
```

```{r Print boxplot for mean power spectral density low sampling frequency experiment, echo=FALSE}
plot(meanpsd_low)
```

### High sampling frequency experiment

```{r Fit model meanPSD for high sampling frequency experiment, echo=FALSE}
meanPSD_interaction_id_high <- lme4::lmer(meanPSD ~ bin*brand + (1 | serialnumber), REML = TRUE, data = df_long$high)

# Evaluate if adding a random intercept for frequency bin is necessary
meanPSD_interaction_id_bin_high <- lme4::lmer(meanPSD ~ bin*brand + (1 | serialnumber) + (1 | bin), REML = TRUE, data = df_long$high) # No convergence, so use simpler model
anova(meanPSD_interaction_id_high, meanPSD_interaction_id_bin_high, refit = FALSE) # This is not necessary, so use simplest model
```

#### Model assumption: normal distributions of residuals
```{r Mean PSD Model assumptions high sampling frequency experiment, echo=FALSE}
ggpubr::ggqqplot(df_long$high, "meanPSD", facet.by = "bin", 
                 title = "QQ-plot mean power spectral density")
residuals_meanPSD <- resid(meanPSD_interaction_id_high)
#summary(residuals_meanPSD)
hist(residuals_meanPSD)
```
#### Model summary
```{r Model summary meanPSD high sampling frequency experiment, echo=FALSE}
car::Anova(meanPSD_interaction_id_high, type="II", test.statistic="F")
require(lmerTest)
test.meanPSD_high <- as(meanPSD_interaction_id_high, "merModLmerTest")
print(summary(test.meanPSD_high, ddf="Kenward-Roger"), correlation = FALSE)
#summary(meanPSD_interaction_id_high)
vcov(meanPSD_interaction_id_high, type = "random")

#drop1(meanPSD_interaction_id_high,scope=c("brand","bin","bin:brand"),test="Chisq")
```

#### Pairwise comparisons

##### Bin
```{r Calculate contrasts bin meanPSD for high sampling frequency experiment, echo=FALSE}
maineffect_bin <- emmeans::emmeans(meanPSD_interaction_id_high, comparison="pairwise", 
                                         specs= ~ bin, adjust="sidak", data = df_long$high)
maineffect_bin
emmeans::contrast(maineffect_bin, "pairwise")
```

##### Interaction
There is no interaction effect
```{r Calculate contrasts model meanPSD for high sampling frequency experiment, echo=FALSE}
#calculateContrasts(meanPSD_interaction_id_high, df_long$high)
```

#### Boxplot
This section presents a boxplot to illustrate differences in mean power spectral density between brands per bin for the high sampling frequency experiment.

```{r Create boxplot mean PSD high sampling frequency, include=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_ms_HA_dataset_long_hf.RData"))
bxp_psd_high <- createBoxplot(df_long$high, bins_high, outcome = "meanPSD", experiment = "high", relative = FALSE) 
bxp_psd_high_perc <- createBoxplot(df_long$high, bins_high, outcome = "meanPSD", experiment = "high", relative = TRUE)

gridExtra::grid.arrange(bxp_psd_high, bxp_psd_high_perc, nrow=1) #arranges plots within grid
meanpsd_high <- gridExtra::arrangeGrob(bxp_psd_high + ggplot2::theme(legend.position="none"),
                                bxp_psd_high_perc + ggplot2::theme(legend.position="bottom"), 
                                nrow=2) #generates meanpsd_high
ggplot2::ggsave(file=paste0(datadir, "plots/boxplots_meanpsd_HIGH_.pdf"), meanpsd_high) #saves meanpsd_high
```

```{r Print boxplot for mean power spectral density high sampling frequency experiment, echo=FALSE}
plot(meanpsd_high)
```

## Dominant frequency: domFreq ~ brand + bin + brand*bin

### Low sampling frequency experiment
```{r Fit model domFreq for low sampling frequency experiment, echo=FALSE}
domFreq_interaction_id_low <- lme4::lmer(domFreq ~ bin*brand + (1 | serialnumber), REML = TRUE, data = df_long$low)

# Evaluate if adding a random intercept for frequency bin is necessary
domFreq_interaction_id__bin_low <- lme4::lmer(domFreq ~ bin*brand + (1 | serialnumber) + (1 | bin), REML = TRUE, data = df_long$low)
anova(domFreq_interaction_id_low, domFreq_interaction_id__bin_low, refit = FALSE) # This is not necessary, so use simplest model
```

#### Model assumption: normal distribution of residuals
```{r Dominant frequency Model assumptions low sampling frequency experiment, echo=FALSE}
ggpubr::ggqqplot(df_long$low, "domFreq", facet.by = "bin", title = "QQ-plot dominant frequency")
residuals_domFreq <- resid(domFreq_interaction_id_low)
#summary(residuals_domFreq)
hist(residuals_domFreq) # approximately normally distributed
```

#### Model summary
```{r Model summary domFreq low sampling frequency experiment, echo=FALSE}
car::Anova(domFreq_interaction_id_low, type="II", test.statistic="F")
require(lmerTest)
test.domFreq_low <- as(domFreq_interaction_id_low, "merModLmerTest")
print(summary(test.domFreq_low, ddf="Kenward-Roger"), correlation = FALSE)
#summary(domFreq_interaction_id_low)
vcov(domFreq_interaction_id_low, type = "random")

#drop1(domFreq_interaction_id_low,scope=c("brand","bin","bin:brand"),test="Chisq")
```

#### Pairwise comparisons
##### Bin
```{r Calculate contrasts bin domFreq for low sampling frequency experiment, echo=FALSE}
maineffect_bin <- emmeans::emmeans(domFreq_interaction_id_low, comparison="pairwise", 
                                         specs= ~ bin, adjust="sidak", data = df_long$low)
maineffect_bin
emmeans::contrast(maineffect_bin, "pairwise")
```

##### Brand
```{r Calculate contrasts brand domFreq for low sampling frequency experiment, echo=FALSE}
maineffect_brand <- emmeans::emmeans(domFreq_interaction_id_low, comparison="pairwise", 
                                         specs= ~ brand, adjust="sidak", data = df_long$low)
maineffect_brand
emmeans::contrast(maineffect_brand, "pairwise")
```

##### Interaction
```{r Calculate contrasts model domFreq for low sampling frequency experiment, echo=FALSE}
calculateContrasts(domFreq_interaction_id_low, df_long$low)
```

#### Boxplot
This section presents a boxplot to illustrate differences in dominant frequency between brands per bin for the low sampling frequency experiment.

```{r Create boxplot domFreq low sampling frequency experiment, include=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_long.RData"))

bxp_domfreq_low <- createBoxplot(df_long$low, bins_low, outcome = "domFreq", experiment = "low", relative = FALSE)
bxp_domfreq_low_perc <- createBoxplot(df_long$low, bins_low, outcome = "domFreq", experiment = "low", relative = TRUE)

gridExtra::grid.arrange(bxp_domfreq_low, bxp_domfreq_low_perc, nrow=1) #arranges plots within grid
domfreq_low <- gridExtra::arrangeGrob(bxp_domfreq_low + ggplot2::theme(legend.position="none"), 
                            bxp_domfreq_low_perc + ggplot2::theme(legend.position="bottom"), nrow=2) #generates domfreq_low 
ggplot2::ggsave(file=paste0(datadir, "plots/boxplots_dominant-frequency_LOW.pdf"), domfreq_low) #saves domfreq_low
```

```{r Print boxplot for dominant frequency low sampling frequency experiment, echo=FALSE}
plot(domfreq_low)
```

### High sampling frequency experiment
```{r Fit model domFreq for high sampling frequency experiment, echo=FALSE}
domFreq_interaction_id_high <- lme4::lmer(domFreq ~ bin*brand + (1 | serialnumber), REML = TRUE, data = df_long$high)

# Evaluate if adding a random intercept for frequency bin is necessary
domFreq_interaction_id_bin_high <- lme4::lmer(domFreq ~ bin*brand + (1 | serialnumber) + (1 | bin), REML = TRUE, data = df_long$high)
anova(domFreq_interaction_id_high, domFreq_interaction_id_bin_high, refit = FALSE) # This is not necessary, so use simplest model
```

#### Model assumption: normal distributions of residuals
```{r Dominant frequency Model assumptions high sampling frequency experiment, echo=FALSE}
ggpubr::ggqqplot(df_long$high, "domFreq", facet.by = "bin", title = "QQ-plot dominant frequency")
residuals_domFreq <- resid(domFreq_interaction_id_high)
#summary(residuals_domFreq)
hist(residuals_domFreq) # approximately normally distributed
```
#### Model summary
```{r Model summary domFreq high sampling frequency experiment, echo=FALSE}

car::Anova(domFreq_interaction_id_high, type="II", test.statistic="F")
require(lmerTest)
test.domFreq_high <- as(domFreq_interaction_id_high, "merModLmerTest")
print(summary(test.domFreq_high, ddf="Kenward-Roger"), correlation = FALSE)
#summary(domFreq_interaction_id_high)
vcov(domFreq_interaction_id_high, type = "random")

#drop1(domFreq_interaction_id_high,scope=c("brand","bin","bin:brand"),test="Chisq")
```

#### Pairwise comparisons
##### Bin
```{r Calculate contrasts bin domFreq for high sampling frequency experiment, echo=FALSE}
maineffect_bin<- emmeans::emmeans(domFreq_interaction_id_high, comparison="pairwise", 
                                         specs= ~ bin, adjust="sidak", data = df_long$high)
maineffect_bin
emmeans::contrast(maineffect_bin, "pairwise")
```
##### Brand
```{r Calculate contrasts brand domFreq for high sampling frequency experiment, echo=FALSE}
maineffect_brand <- emmeans::emmeans(domFreq_interaction_id_high, comparison="pairwise", 
                                         specs= ~ brand, adjust="sidak", data = df_long$high)
maineffect_brand
emmeans::contrast(maineffect_brand, "pairwise")
```
##### Interaction
```{r Calculate contrasts model domFreq for high sampling frequency experiment, echo=FALSE}
calculateContrasts(domFreq_interaction_id_high, df_long$high)
```

#### Boxplot
This section presents a boxplot to illustrate differences in dominant frequency between brands per bin for the high sampling frequency experiment.

```{r Create boxplot domFreq high sampling frequency, include=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_ms_HA_dataset_long_hf.RData"))
bxp_domfreq_high <- createBoxplot(df_long$high, bins_high, outcome = "domFreq", experiment = "high", relative = FALSE)
bxp_domfreq_high_perc <- createBoxplot(df_long$high, bins_high, outcome = "domFreq", experiment = "high", relative = TRUE)

gridExtra::grid.arrange(bxp_domfreq_high, bxp_domfreq_high_perc, nrow=1) #arranges plots within grid
domfreq_high <- gridExtra::arrangeGrob(bxp_domfreq_high + ggplot2::theme(legend.position="none"), 
                            bxp_domfreq_high_perc + ggplot2::theme(legend.position="bottom"), nrow=2) #generates domfreq_high
ggplot2::ggsave(file=paste0(datadir, "plots/boxplots_dominant-frequency_HIGH.pdf"), domfreq_high) #saves domfreq_high
```

```{r Print boxplot for dominant frequency high sampling frequency experiment, echo=FALSE}
plot(domfreq_high)
```

```{r Create boxplot mean power spectral density, include=FALSE}
gridExtra::grid.arrange(bxp_psd_high, bxp_psd_low, nrow=1) #arranges plots within grid
g <- gridExtra::arrangeGrob(bxp_psd_high + ggplot2::theme(legend.position="none"), 
                            bxp_psd_low + ggplot2::theme(legend.position="bottom"), nrow=2) #generates g
ggplot2::ggsave(file=paste0(datadir, "plots/boxplot_meanPSD.pdf"), g) #saves g
```


```{r Create boxplot dominant frequency, include=FALSE}
gridExtra::grid.arrange(bxp_domfreq_high, bxp_domfreq_low, nrow=1) #arranges plots within grid
g <- gridExtra::arrangeGrob(bxp_domfreq_high + ggplot2::theme(legend.position="none"), 
                            bxp_domfreq_low + ggplot2::theme(legend.position="bottom"), nrow=2) #generates g
ggplot2::ggsave(file=paste0(datadir, "plots/boxplot_domFreq.pdf"), g) #saves g
```
