---
title: "Frequency domain analyses"
output: pdf_document
---

```{r Setup and load data, include=FALSE}
#install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE)

rm(list=ls())
graphics.off()

# Update to be your local directory, if all goes well this is the only line you will have to update
shaker_experiments_folder = "/Users/annelindelettink/Documents/Work MacBook Pro Annelinde/Mechanical Shaker Machine"
# shaker_experiments_folder = "~/data/VUMC/shaker_experiments"

#====================================================================================
# Specify file paths
datadir = paste0(shaker_experiments_folder, "/analyses/")
if (!dir.exists(datadir)) {
  stop(paste0("Directory does not exist: ", datadir))
}
# Load mechanical shaker data for horizontal axis 
filename_flatHA = paste0(datadir, "ms_flat_HA.RData") 
if (!file.exists(filename_flatHA)) {
  stop(paste0("File does not exist: ", filename_flatHA))
}
load(filename_flatHA)

# Select data of high and low sampling frequency experiments only
data <- ms_flat_HA$data[ms_flat_HA$specifications$experiment == "ms_hfcr" | ms_flat_HA$specifications$experiment == "ms_lfcr"]
specifications <- ms_flat_HA$specifications[ms_flat_HA$specifications$experiment == "ms_hfcr" | ms_flat_HA$specifications$experiment == "ms_lfcr",]
rm(ms_flat_HA, filename_flatHA, shaker_experiments_folder)
```

```{r Functions, include=FALSE}
#' deriveSpectrum
#'
#' @description 'deriveSpectrum' derives the frequency spectrum of a signal (called from within derivePeakIntervals to derive smoothed spectrum)
#'
#' @param x Vector that contains the values of the signal (i.e., acceleration)
#' @param sampling_frequency Integer that indicates the sampling frequency of the signal (i.e., the average number of samples obtained in one second in Hz)
#' @param raw Boolean, if TRUE the raw frequency spectrum will be derived, FALSE: smoothed spectrum will be derived
#' @param file_name String to indicate the name of the plot (i.e., "spectrum" result in the following name for plot 1 "spectrum_1.jpeg").
#' @return An object of class "spec", which is a list containing at least the following components: 
#' \item{freq}{Vector of frequencies at which the spectral density is estimated.} 
#' \item{spec}{Vector (for univariate series) or matrix (for multivariate series) of estimates of the spectral density at frequencies corresponding to freq.}
#' \item{coh}{NULL for univariate series. For multivariate time series, a matrix containing the squared coherency between different series.}  
#' \item{phase}{NULL for univariate series. For multivariate time series a matrix containing the cross-spectrum phase between different series.} 
#' \item{series}{The name of the time series.}
#' \item{snames}{For multivariate input, the names of the component series.}
#' \item{method}{The method used to calculate the spectrum.} 
#' @export
deriveSpectrum <- function(x, sampling_frequency, raw = TRUE, file_name) {
  if(raw == TRUE){
    specd <- spectrum(x, log = "no", plot = FALSE) # Default is to calculate the spectrum on a log-scale, but we use the raw data
  } else {
    specd <- spectrum(x, log = "no", span = 75, plot = FALSE) # Smooth the raw signal
  }
  # The frequency axis of the spectrum, specd, is calculated in terms of cycles per sampling interval
  delta <- 1/sampling_frequency
  specd$specx <- specd$freq/delta # Convert to cycles per unit time (so divide by the sampling interval)
  specd$specy <- 2*specd$spec # Multiply the spectrum by 2 to make it actually equal to variance
  
  #Save the frequency spectrum plot
  if (plot == TRUE){
    jpeg(paste(datadir, paste0(paste(file_name, file, sep = "_"), ".jpeg"), sep = "/plots/"), width=600, height=500, res=120) # start export
    plot(specd$specx, specd$specy,
         main = "HA", xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l") # Zoom in on low-frequencies (at most 5 is expected based on max rpm)
    dev.off()
  }
  return(specd)
}

#' deriveComparisonValues
#'
#' @description 'deriveComparisonValues' derives the dominant frequency and the mean power spectral density from a frequency spectrum
#'
#' @param spectrum An object of class "spec"
#' @param freqBins Vector containing frequency values that define the frequency bins (can be derived using the function 'defineFreqBins') 
#' @return Data.frame consisting of two columns: \item{domFreq}{The dominant frequency of the signal in each frequency bin} \item{meanPSD}{The mean power spectral density of the signal in each frequency bin}
#' @export
deriveComparisonValues <- function(spectrum, freqBins){
  df <- data.frame()
  for(i in 1:(length(freqBins)-1)){
    lower <- freqBins[i]
    upper <- freqBins[i+1]
    index <- which(spectrum$specx >= lower & spectrum$specx <= upper)
    df[i, 1] <- spectrum$specx[index[which.max(spectrum$specy[index])]] # dominant frequency
    df[i, 2] <- mean(spectrum$specy[index]) # mean Power spectral density
  }
  colnames(df) <- c("domFreq", "meanPSD")
  return(df)
}

#' createBoxplot
#'
#' @description 'createBoxplot' creates a boxplot between or within devices for the dominant frequency or the mean power spectral density per frequency bin
#'
#' @param data A data set containing the comparison values for the experiment
#' @param outcome String containing the type of the comparison value. One of c("domFreq", "meanPSD") 
#' @param type String containing the axis the outcome value is derived from. One of c("within", "between") 
#' @param logscale Boolean to indicate whether the vertical axis needs to be logtransformed. One of c("TRUE", "FALSE") 
#' @return Boxplot between or within devices for the outcome (y-axis) per frequency bin (x-axis)
#' @export
createBoxplot <- function(data, outcome = c("domFreq", "meanPSD"), type = c("within", "between"), logscale = c(TRUE, FALSE)){
  if(type == "between"){
    per = "brand"
  } else {
    per = "id"
  }
  if (outcome == "domFreq"){
    label = "Dominant frequency (Hertz)"
  } else{
    label = "Mean PSD (g2/Hertz)"
  }

  boxplot <- ggpubr::ggboxplot(data, x = "freqBin", y = outcome, color = per,
                               xlab = "Mean frequency bin (Hertz)", ylab = label, order = c("t0", "t1", "t2", "t3", "t4",
                                                                                         "t5", "t6", "t7", "t8", "t9",
                                                                                         "t10"), 
                               font.label = list(size = 8, color = "black")) +
            scale_x_discrete(breaks=c("t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9", "t10"),
                             labels= c("0.25",  "0.67", "1.04", "1.46", "1.88", "2.29", "2.71", "3.13", "3.54", "3.96",
                                       "4.59")) 
  if(logscale == TRUE){
    boxplot <- boxplot + ggpubr::yscale("log10", .format = TRUE)
  }
  return(boxplot)
}

#' evaluateMM
#'
#' @description 'evaluateMM' function to indicate if the likelihood ratio test was significant
#'
#' @param model1 Model object with the least parameters
#' @param model2 Model object with the most parameters
#' @param type String containing the addition to the model. One of c("randomIntercept", "randomSlope") 
#' @return Boolean: \item{TRUE}{The addition of a random intercept/slope is necessary} \item{FALSE}{The addition of a random intercept/slope is not necessary}
#' @export
evaluateMM <- function(model1, model2, type = c("randomIntercept", "randomSlope")){
  logLikDiff <- (-2*(logLik(model1))) - (-2*logLik(model2))
  if(type == "randomIntercept"){
    return(logLikDiff > 3.84)
  }
  else{ 
    return(logLikDiff > 5.99)
  }
}

#' getOutputMM
#'
#' @description 'getOutputMM' function print the model output
#'
#' @param finalModel Model object for which the output will be printed
#' @return Printed model output including fixed and random effect estimates
#' @export
getOutputMM <- function(finalModel) {
  print(summary(finalModel)) #fixed effect estimates
  lme4::VarCorr(finalModel) #random effect estimates
}
```

# Raw frequency spectra

In this section the raw frequency spectra are printed for each accelerometer recording separately.

```{r Derive frequency spectra, echo=FALSE}
# Note: Activpal was set to a sampling frequency of 20 Hz (in both experiments), however, these data were considered both experiments (ms_hfcr and ms_lfcr) as the recorded amplitude was expected to be the same.

# Plot parameters
plot = TRUE
xlabel = "Frequency (Hertz)"
ylabel = "Spectral Density (g2/Hertz)"
XLIM = c(0, 5) # Limit frequency content to 5 Hz (as 250 rpm / 60 = 4.1667 Hz is the expected max)

# DERIVE RAW FREQUENCY SPECTRA (for visual inspection and save data for further analysis)
raw.spectra_HA <- list() 
for (file in 1:length(data)) { # for all accelerometer files
  sampling_frequency <- as.numeric(specifications$sampling_frequency[file])  
  HA <- data[[file]]$HA #for horizontal axis
  rawSpectrum_HA <- deriveSpectrum(HA, sampling_frequency, raw = TRUE, file_name = names(data)[[file]])
  raw.spectra_HA[[file]] <- rawSpectrum_HA
}
rm(rawSpectrum_HA)
names(raw.spectra_HA) <- specifications$label  
raw_spectra <- list(HA = raw.spectra_HA, specifications = data$specifications) # Save derived raw spectra for HA in one list
#cat("\nSaving data...")
save(raw_spectra, file = paste0(datadir, "frequency_spectra_HA.RData"))
rm(raw.spectra_HA, HA, sampling_frequency, file)
```

## Visual inspection
Visual inspection of the saved spectrum plots showed clear deviations for:

```{r Remove data of deviating spectra, echo=TRUE}
deviations <- c(42, 51, 55, 64, 78, 93)
specifications$label[deviations] 

# Raw data inspection of these devices
#AP672490: in both experiments raw values around 7.3 (M = 7.332, SD = 0.01083037)
# measured during all shaking frequencies
mean(data$aP_490$HA)
sd(data$aP_490$HA)
#AP473254: in both experiments values around 0.3 (M = 0.32503, SD = 0.00628132) 
# measured during all shaking frequencies
mean(data$aP_254$HA)
sd(data$aP_254$HA)
#6011406: in both experiments value around 0 (M = -0.0148, SD = 0.2275247) 
# min of -14 and max of -22 during shaking frequency of 0
mean(data$Ax_406$HA)
sd(data$Ax_406$HA)
```

```{r Save data without deviates, include = FALSE}
# Remove data of these devices for now
data[deviations] <- NULL
specifications <- specifications[-deviations,]
raw_spectra$HA[deviations] <- NULL
rm(deviations)
# Save as new data set
ms_flat_HA_new <- list(data = data, specifications = specifications)
#cat("\nSaving data...")
save(ms_flat_HA_new, file = paste0(datadir, "ms_flat_HA_deviates_removed.RData"))
```

## Spectrum plots with mechanical shaker cutoffs

```{r Mechanical Shaker Cuttoffs, echo=FALSE}
#load(paste0(datadir, "ms_flat_HA_deviates_removed.RData"))
rpm <- c(30, 50, 75, 100, 125, 150, 175, 200, 225, 250)
shaking_frequencies <- rpm / 60

# Plot spectra with these cutoffs
for (spectrum in 1:length(raw_spectra$HA)) {
  title <- paste0(names(raw_spectra$HA)[[spectrum]], " with mechanical shaker cutoffs")
  plot(raw_spectra$HA[[spectrum]]$specx, raw_spectra$HA[[spectrum]]$specy,
       main = title, xlab = xlabel, ylab = ylabel, type = "l", xlim = XLIM, bty= "l") # Zoom in on low-frequencies (at most 5 is expected based on max rpm)
  for(i in 1:length(shaking_frequencies)){
    abline(v=shaking_frequencies[i], col = "red")
    abline(v=shaking_frequencies[i], col = "red")
  }  
}
rm(spectrum, i)
```

```{r Compute dominant frequency (domFreq) and mean power spectral density (meanPSD) for HA , include = FALSE}
# Derive frequency bins from the cutoffs
freqBins <- round(c(XLIM[1], shaking_frequencies, XLIM[2]), digits = 2)
rm(rpm, shaking_frequencies)

comparison_values <- list()
for(spectrum in 1:length(raw_spectra$HA)){ 
  cat(paste0(spectrum, "/",  length(raw_spectra$HA), " "))
  spectrum.raw <- raw_spectra$HA[[spectrum]]
  values <- deriveComparisonValues(spectrum.raw, freqBins)
  comparison_values[[spectrum]] <- values
}
names(comparison_values) <- names(raw_spectra$HA)
#cat("\nSaving data...")
save(comparison_values, file = paste0(datadir, "domfreq_meanPSD_HA_freqbins.RData")) # Save computed comparison values for HA in one list
rm(spectrum, values, spectrum.raw, raw_spectra)
```

```{r Prepare data set for statistical analyses, include = FALSE}
# Wide format: for both outcomes domFreq and meanPSD
df_wide <- data.frame()
id <- names(comparison_values)
df_wide <- cbind(id, specifications$brand, specifications$experiment, specifications$sampling_frequency, specifications$dynamic_range)

domFreq_wide <- data.frame() 
meanPSD_wide <- data.frame()
for (accelerometer in 1:length(comparison_values)) {
  domFreq_wide <- rbind(domFreq_wide, comparison_values[[accelerometer]]$domFreq)
  meanPSD_wide <- rbind(meanPSD_wide, comparison_values[[accelerometer]]$meanPSD)
}

domFreq_ms_wide <- cbind(df_wide, domFreq_wide)
colnames(domFreq_ms_wide) <- c("id", "brand", "experiment", "sampling_frequency", "dynamic_range", 
                               "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9", "t10")
meanPSD_ms_wide <- cbind(df_wide, meanPSD_wide)
colnames(meanPSD_ms_wide) <- c("id", "brand", "experiment", "sampling_frequency", "dynamic_range", 
                               "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9", "t10")
rm(df_wide, id, domFreq_wide, meanPSD_wide, accelerometer)

# Long format: combining domFreq and meanPSD (gather columns for outcome variables)
library(tidyverse)
domFreq_long <- domFreq_ms_wide %>%
  gather(key = "freqBin", value = "domFreq", t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) %>%
  rstatix::convert_as_factor(id, freqBin, brand, experiment, sampling_frequency, dynamic_range)
meanPSD_long <- meanPSD_ms_wide %>%
  gather(key = "freqBin", value = "meanPSD", t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) %>%
  rstatix::convert_as_factor(id, freqBin, brand, experiment, sampling_frequency, dynamic_range)
df_long <- merge(domFreq_long, meanPSD_long) # Join both data.frame objects to derive a single dataset
cat("\nSaving data...")
save(df_long, file = paste0(datadir, "domfreq_meanPSD_ms_HA_dataset_long.RData"))
rm(comparison_values, domFreq_ms_wide, meanPSD_ms_wide, domFreq_long, meanPSD_long)

# Subset: data for high and low frequency experiments
df_high <- df_long[df_long$experiment == "ms_hfcr",] 
df_high <- df_high[order(df_high$id),]
df_low <- df_long[df_long$experiment == "ms_lfcr",] 
df_low <- df_low[order(df_low$id),]

cat("\nSaving data...")
save(df_high, file = paste0(datadir, "domfreq_meanPSD_ms_HA_dataset_long_hf.RData"))
save(df_low, file = paste0(datadir, "domfreq_meanPSD_HA_ms_dataset_long_lf.RData"))
rm(df_long)
```

# Statistical comparison

## Low sampling frequency experiment

```{r Boxplots low sampling frequency experiment, echo=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_HA_ms_dataset_long_lf.RData"))

bxp_domfreq_low <- createBoxplot(df_low, outcome = "domFreq", type = "between", logscale = FALSE) # Dominant frequency
bxp_psd_low <- createBoxplot(df_low, outcome = "meanPSD", type = "between", logscale = FALSE) # Mean PSD
gridExtra::grid.arrange(bxp_domfreq_low, bxp_psd_low, nrow=1) #arranges plots within grid
g <- gridExtra::arrangeGrob(bxp_domfreq_low + theme(legend.position="none"), bxp_psd_low + theme(legend.position="bottom"), nrow=2) #generates g 
#ggsave(file=paste0(datadir, "plots/boxplots_HA_LOW.pdf"), g) #saves g

bxp_domfreq_low_log <- createBoxplot(df_low, outcome = "domFreq", type = "between", logscale = TRUE) # Dominant frequency
bxp_psd_low_log <- createBoxplot(df_low, outcome = "meanPSD", type = "between", logscale = TRUE) # Mean PSD
gridExtra::grid.arrange(bxp_domfreq_low_log, bxp_psd_low_log, nrow=1) #arranges plots within grid
g_log <- gridExtra::arrangeGrob(bxp_domfreq_low_log + theme(legend.position="none"), bxp_psd_low_log + theme(legend.position="bottom"), nrow=2) #generates g_log
#ggsave(file=paste0(datadir, "plots/boxplots_HA_LOW_logscale.pdf"), g_log) #saves g_log

#rm(bxp_domfreq_low, bxp_psd_low, bxp_domfreq_low_log, bxp_psd_low_log, g, g_log)
```
Mixed model analyses

```{r Mixed Model Analyses low sampling frequency experiment, include=FALSE}
# Starting model: with random intercept for accelerometer id (to adjust for the repeated measurements of the accelerometer devices)
meanPSD_intercept_id_low <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_low)
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)

# Add random intercept for freqBin (to adjust for the frequencies)
meanPSD_intercept_freqbin_low <- nlme::lme(meanPSD ~ brand, random = list(~ 1|id, ~ 1|freqBin), method="ML", data = df_low)
domFreq_intercept_freqbin_low <- nlme::lme(domFreq ~ brand, random = list(~ 1|id, ~ 1|freqBin), method="ML", data = df_low)

# Evaluate if adding a random intercept for freqBin is necessary
evaluateMM(meanPSD_intercept_id_low, meanPSD_intercept_freqbin_low, type = "randomIntercept") #FALSE adding a random intercept for frequency bin to the model is not necessary
evaluateMM(domFreq_intercept_id_low, domFreq_intercept_freqbin_low, type = "randomIntercept") #FALSE adding a random intercept for frequency bin to the model is not necessary
rm(meanPSD_intercept_freqbin_low, domFreq_intercept_freqbin_low)
```

Model assumptions

```{r Model assumptions low sampling frequency experiment, echo=FALSE}
cat("Normal distribution of residuals")
cat("Mean PSD")
ggpubr::ggqqplot(df_low, "meanPSD", facet.by = "freqBin")
residuals_meanPSD <- resid(meanPSD_intercept_id_low)
summary(residuals_meanPSD)
hist(residuals_meanPSD)
cat("Dominant frequency")
ggpubr::ggqqplot(df_low, "domFreq", facet.by = "freqBin")
residuals_domFreq <- resid(domFreq_intercept_id_low)
summary(residuals_domFreq)
hist(residuals_domFreq) # approximately normally distributed
```

Results Mean Power Spectral Density

Reference: ActiGraph 
```{r Report results for Mean PSD low sampling frequency experiment: ActiGraph, echo=FALSE}
getOutputMM(meanPSD_intercept_id_low)
```
Reference: MOX
```{r Report results for Mean PSD low sampling frequency experiment: MOX, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
meanPSD_intercept_id_low <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(meanPSD_intercept_id_low)
```
Reference: GENEActiv 
```{r Report results for Mean PSD low sampling frequency experiment: GENEActiv, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
meanPSD_intercept_id_low <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(meanPSD_intercept_id_low)
```
Reference: Axivity 
```{r Report results for Mean PSD low sampling frequency experiment: Axivity, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
meanPSD_intercept_id_low <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(meanPSD_intercept_id_low)
```
Reference: activPAL 
```{r Report results for Mean PSD low sampling frequency experiment: activPAL, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
meanPSD_intercept_id_low <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(meanPSD_intercept_id_low)
```
Dominant frequency 

Reference: ActiGraph 
```{r Report results for Dominant frequency low sampling frequency experiment: ActiGraph, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(domFreq_intercept_id_low)
```
Reference: MOX 
```{r Report results for Dominant frequency low sampling frequency experiment: MOX, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(domFreq_intercept_id_low)
```
Reference: GENEActiv 
```{r Report results for Dominant frequency low sampling frequency experiment: GENEActiv, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(domFreq_intercept_id_low)
```
Reference: Axivity 

```{r Report results for Dominant frequency low sampling frequency experiment: Axivity, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(domFreq_intercept_id_low)
```
Reference: activPAL 

```{r Report results for Dominant frequency low sampling frequency experiment: activPAL, echo=FALSE}
df_low$brand <- relevel(df_low$brand, ref = 5) 
domFreq_intercept_id_low <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_low)
getOutputMM(domFreq_intercept_id_low)
```
# High sampling frequency experiment

```{r Boxplots high sampling frequency, echo=FALSE}
#load(paste0(datadir, "domfreq_meanPSD_ms_HA_dataset_long_hf.RData"))
bxp_domfreq_high <- createBoxplot(df_high, outcome = "domFreq", type = "between", logscale = FALSE) # Dominant frequency
bxp_psd_high <- createBoxplot(df_high, outcome = "meanPSD", type = "between", logscale = FALSE) # Mean PSD
gridExtra::grid.arrange(bxp_domfreq_high, bxp_psd_high, nrow=1) #arranges plots within grid
g <- gridExtra::arrangeGrob(bxp_domfreq_high + theme(legend.position="none"), bxp_psd_high + theme(legend.position="bottom"), nrow=2) #generates g
#ggsave(file=paste0(datadir, "plots/boxplots_HA_HIGH.pdf"), g) #saves g

bxp_domfreq_high_log <- createBoxplot(df_high, outcome = "domFreq", type = "between", logscale = TRUE) # Dominant frequency
bxp_psd_high_log <- createBoxplot(df_high, outcome = "meanPSD", type = "between", logscale = TRUE) # Mean PSD
gridExtra::grid.arrange(bxp_domfreq_high_log, bxp_psd_high_log, nrow=1) #arranges plots within grid
g_log <- gridExtra::arrangeGrob(bxp_domfreq_high_log + theme(legend.position="none"), bxp_psd_high_log + theme(legend.position="bottom"), nrow=2) #generates g_log
#ggsave(file=paste0(datadir, "plots/boxplots_HA_HIGH_logscale.pdf"), g_log) #saves g_log

#rm(bxp_domfreq_high, bxp_psd_high, bxp_domfreq_high_log, bxp_psd_high_log, g, g_log)
```
Mixed model analyses

```{r Mixed Model Analyses high sampling frequency experiment, include=FALSE}
# Starting model: with random intercept for accelerometer id (to adjust for the repeated measurements of the accelerometer devices)
meanPSD_intercept_id_high <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_high)
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)

# Add random intercept for freqBin (to adjust for the frequencies)
meanPSD_intercept_freqbin_high <- nlme::lme(meanPSD ~ brand, random = list(~ 1|id, ~ 1|freqBin), method="ML", data = df_high)
domFreq_intercept_freqbin_high <- nlme::lme(domFreq ~ brand, random = list(~ 1|id, ~ 1|freqBin), method="ML", data = df_high)

# Evaluate if adding a random intercept for freqBin is necessary
evaluateMM(meanPSD_intercept_id_high, meanPSD_intercept_freqbin_high, type = "randomIntercept") #FALSE adding a random intercept for frequency bin to the model is not necessary
evaluateMM(domFreq_intercept_id_high, domFreq_intercept_freqbin_high, type = "randomIntercept") #FALSE adding a random intercept for frequency bin to the model is not necessary
rm(meanPSD_intercept_freqbin_high, domFreq_intercept_freqbin_high)
```

Model assumptions

```{r Model assumptions high sampling frequency experiment, echo=FALSE}
cat("Normal distribution of residuals")
cat("Mean PSD")
ggpubr::ggqqplot(df_high, "meanPSD", facet.by = "freqBin")
residuals_meanPSD <- resid(meanPSD_intercept_id_high)
summary(residuals_meanPSD)
hist(residuals_meanPSD)
cat("Dominant frequency")
ggpubr::ggqqplot(df_high, "domFreq", facet.by = "freqBin")
residuals_domFreq <- resid(domFreq_intercept_id_high)
summary(residuals_domFreq)
hist(residuals_domFreq) # approximately normally distributed

```

Mean Power Spectral Density 

Reference: ActiGraph
```{r Report results for Mean PSD high sampling frequency experiment: ActiGraph, echo=FALSE}
getOutputMM(meanPSD_intercept_id_high)
```
Reference: MOX
```{r Report results for Mean PSD high sampling frequency experiment: MOX, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
meanPSD_intercept_id_high <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(meanPSD_intercept_id_high)
```

Reference: GENEActiv
```{r Report results for Mean PSD high sampling frequency experiment: GENEActiv, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
meanPSD_intercept_id_high <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(meanPSD_intercept_id_high)
```
Reference: Axivity

```{r Report results for Mean PSD high sampling frequency experiment: Axivity, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
meanPSD_intercept_id_high <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(meanPSD_intercept_id_high)
```
Reference: activPAL

```{r Report results for Mean PSD high sampling frequency experiment: activPAL, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
meanPSD_intercept_id_high <- nlme::lme(meanPSD ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(meanPSD_intercept_id_high)
```
Dominant Frequency

Reference: ActiGraph

```{r Report results for Dominant frequency high sampling frequency experiment: ActiGraph, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(domFreq_intercept_id_high)
```

Reference: MOX

```{r Report results for Dominant frequency high sampling frequency experiment: MOX, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(domFreq_intercept_id_high)

```
Reference: GENEActiv

```{r Report results for Dominant frequency high sampling frequency experiment: GENEActiv, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(domFreq_intercept_id_high)

```

Reference: Axivity

```{r Report results for Dominant frequency high sampling frequency experiment: Axivity, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(domFreq_intercept_id_high)

```
Reference: activPAL

```{r Report results for Dominant frequency high sampling frequency experiment: activPAL, echo=FALSE}
df_high$brand <- relevel(df_high$brand, ref = 5) 
domFreq_intercept_id_high <- nlme::lme(domFreq ~ brand, random = ~ 1|id, method="ML", data = df_high)
getOutputMM(domFreq_intercept_id_high)

```